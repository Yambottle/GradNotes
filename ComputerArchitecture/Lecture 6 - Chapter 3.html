<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.12 (457936)"/><meta name="altitude" content="173.1559295654297"/><meta name="author" content="chinibottle@gmail.com"/><meta name="created" content="2018-02-08 20:04:32 +0000"/><meta name="latitude" content="32.84292423390654"/><meta name="longitude" content="-96.78272591973119"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-02-15 20:53:31 +0000"/><title>Lecture 6 - Chapter 3</title></head><body><div><ol start="4"><li>ISA: Instruction Set Architecture=&gt; interface between the hardware and the software. This is the view of an assembly language programmer.</li><li>The goal of hardware designer is to implement ISA in the “best” way possible.</li><ol><li>performance</li><li>cost/simple and small</li><li>power consumption/heat</li><li>fault tolerance and reliability=&gt;TMR(Triple Modular Redundancy)</li></ol><li>Things that are common across ISA’s:</li><ol><li>opcode: tells me what the instruction is</li><li>instructions contain operands that determine what data will be used</li><ol><li>integer arithmetic/ logic</li><li>floating point arithmetic</li><li>memory transfer</li><li>control instructions</li></ol><li>n-bit number: </li><ol><li>Max: 2^(n-1)-1</li><li>Min: -2^(n-1)</li></ol><li>Exceptions:</li><ol><li>Overflow: number too big to be represent in the register</li><li>logic operation: don’t rise exceptions</li></ol><li>integer instructions except * or /, take 1 cycle in the ALU</li></ol><li>Floating point:</li><ol><li>Single precision format: 1bit-sign, 8bit-exponent, 23bit-mantissa; bias: 127</li><li>Double precision format: 1bit-sign, 11bit-exponent, 52bit-mantissa; bias: 1023</li><li>Special number is:</li><ol><li>Zero: exponent=0, fraction=0</li><li>De-normal: exponent=0, fraction!=0( just put 0 to the exponent)</li><li>Infinity: exponent=all 1, fraction=1</li><li>NaN: exponent= all 1, fraction!= all </li></ol><li>Multiply:</li><ol><li>add exponent-bias</li><li>multiply significands</li><li>shift the significand and adjust exponents around to put it in the right form</li><li>decide on sign</li></ol><li>Add:</li><ol><li>shift one of the number to align the exponents</li><li>add the significands</li><li>shift to adjust exponents to put it in the right form</li><li>decide on sign</li></ol></ol><li>Memory Access instructions</li><ol><li>Load: LW, LH, LB, LD</li><li>Store: SW, SH, SB, SD</li><li>Our memory is byte addressable: the size of the memory that can be accessed by a given number of bits corresponds to the number of bytes we can individually specify</li><li>16 bits address: 2^16=&gt;64K bytes</li><li>32 bits address: =&gt;4G bytes</li><li>64 bits address: =&gt;16Exa bytes</li></ol><li>In many ISA’s the operands in memory should be “aligned”. This means that the address of an operand is a multiple of its size.</li><ol><li>halfwords(2 bytes) must have addresses that are even(/ by 2)</li><li>words(4 bytes)(/ by 4)</li><li>double word(8 bytes)(/ by 8)</li><li>Misalign: data is placed in the memory and the cache in powers of 2; so the same data will separate into two blocks; when you need to access, need to access twice; computer will often trigger an exception</li></ol><li>Big vs Little Endian</li><ol><li>ox12345678</li><li>big: 12 34 56 78(IBM)</li><li>little: 78 56 34 12(Intel x86)</li><li>run program on different machine will rise exception</li></ol><li>Control Flow instructions:</li><ol><li>they change program exception order</li><ol><li>if we don’t have control flow instruction, next instruction is pc+4(instruction size)</li></ol><li>Branches are conditional:</li><ol><li>the target address is usually specified with PC relative addressing</li><li>if the condition is met, the next instruction is PC(program conter)+4(size of inst)+displacement(positive or neg offset)=&gt;target address for branch</li><li>problem: if I record my instructions dynamically, I can’t predict which instruction determined the current values in the register</li><li>some machines have a condition code register: values in this register were used to determine the outcome of the branch</li><ol><li>Z=&gt;zero; C=&gt;carry; V=&gt;overflow; E=&gt;extend; N=&gt;negative</li></ol><li>problem 2: reordering instructions is hard because last instruction physically executed sets those code</li><li>set a condition code and test when needed<span style="color: rgb(255, 38, 0);">???video</span></li></ol><li>Jump is unconditional:</li><ol><li>Jump address &lt;= most of the target address is stored in instructions: 6bits-op code &amp; 58bits-address</li><li>PC+4bit &amp; 56bits address &amp; 2 bits-0(to align)=&gt; because memory block always plus four, so in binary, the last two bits are always zero</li><ol><li>E.g JR R1</li><li>E.g JAL R28, subroutine: jump and link: used for procedure calls:</li><ol><li>stores return address in a register</li><li>jumps to subroutine(function)</li><li>It is the responsibility of the software to make sure that register are saved as necessary and restored at the end of sub routine</li></ol></ol></ol><li>Instruction Mix: fractions of the various opcode and instruction types in a program</li><ol><li>time vs instruction count</li><li>static vs dynamic</li><ol><li>static instruction mix: distribution of instructions in the program code</li><li>dynamic instruction mix: distribution of executed instructions</li></ol><li>Loops, subroutines, jumps, branches can make dynamic and static instructions different=&gt; <span style="color: rgb(255, 38, 0);">book 3.1 table</span></li></ol></ol></ol></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html>