<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.12 (457936)"/><meta name="altitude" content="172.3651580810547"/><meta name="author" content="chinibottle@gmail.com"/><meta name="created" content="2018-02-06 20:03:06 +0000"/><meta name="latitude" content="32.84291203811237"/><meta name="longitude" content="-96.78273976222287"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-02-06 21:17:45 +0000"/><title>Lecture 5</title></head><body><div><ol start="1"><li><font style="color: rgb(255, 38, 0);">Graph### from video</font></li><li>Optimizations=&gt;</li><ol><li>Multiplier and ALU can be accessed in parallel. registers 0-7 can go to multiplier at the same time, register 8-15 can provide data to ALU. Both functional units can write to any register.</li><li>use an 80 bits(normal is 40) accumulator in the multiplier. They do this to try to keep precision over multiple math operations</li><li><span style="color: rgb(255, 38, 0);">Shadow registers???</span> that allow fast context switching when you have an interrupt</li><ol><li>Motorola 68K: vectored interrupt=&gt; interrupt handler was in memory and pointed to by the vector table. When we wrote the handlers, first job was to save registers onto the stack to allow you to restore state of machines</li><li>DSP instead of writing reg. to stack one at a time, we can transfer to the shadows reg. in one clock cycle of them back at the end of the routine in one more clock cycle</li></ol></ol><li>DPS programming=&gt; </li><ol><li>C: TI document that recommends this</li><li>Assembly: at 1999, equal number of programs written in C. But for every DSP programmed in C, two dollars were made for one programmed in assembly</li></ol><li>E.g Dot product:</li><ol><li>x[ ] dot y[ ]</li><li>x dot y = x[0]*y[0]+’’’’’’’+x[n]*y[n]</li><li>Assume that x and y both have 20 elements, x is stored in DM, y is stored in PM</li><li>C program:</li><ol><li>#define LEN 20</li><li>float dm x[LEN];</li><li>float pm y[LEN];</li><li>main(){</li><li>int n;</li><li>float s = 0;</li><li>for(n=0;n&lt;LEN;n++)</li><ol><li>s+=x[n]*y[n];</li></ol><li>return s;</li><li>}</li></ol><li>Assembly(SHARC): <span style="color: rgb(255, 38, 0);">Code### from video</span></li><ol><li>I: index register that pointer to the memory</li><li>M: step size for ad pointer</li><li>B: base address</li><li>C: number of loc/size of buffer</li><li>lctr = 20: number of iterations</li><li>lce: loop conter expired</li><li>4*20+1 = 81 </li></ol><li>Smarter way to write this to take advantage of the parallelism allow by the DSP arch</li><ol><li>create a software pipeline to do that, we need to do some setup instructions to get it started</li><ol><li><span style="color: rgb(255, 38, 0);">Code### from video</span></li><li>6 cycles to set up + 18 cycles of loop = 24</li><li>speed up rate is about 400%</li></ol></ol><li>C vs Assembly: </li><ol><li>large and complex: C</li><li>performance limited: assembly</li><li>development cost important: C</li><li>DSP manufacture suggestions: Do what they say</li></ol></ol></ol><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html>