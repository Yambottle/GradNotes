<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.12 (457936)"/><meta name="altitude" content="172.6547546386719"/><meta name="author" content="chinibottle@gmail.com"/><meta name="created" content="2018-01-30 20:00:53 +0000"/><meta name="latitude" content="32.85560481008304"/><meta name="longitude" content="-96.75936833416317"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-02-01 21:16:13 +0000"/><title>Lecture 3</title></head><body><div><ol start="1"><li>Performance = 1/Exec Time</li><ol><li><span style="color: rgb(255, 38, 0);">Speedup of A with the speed to B = Exec B/ Exec A</span></li></ol><li><span style="color: rgb(255, 38, 0);">Frequency = 1/clock period</span>!!!</li><li>CPU Execution time for a program:</li><ol><li>depends on numbers of instructions</li><li>clock period </li><li>cycles per instruction</li><li><span style="color: rgb(255, 38, 0);">CPU exec time = IC*CPI*clock period</span> = # inst * clock cycles/ # inst * sec/ clock cycles = sec</li></ol><li>Eg. The code contained I instructions where each instruction takes 3 clock cycles. </li><ol><li>Correllia instructions =&gt;CPI 2   30%</li><li>Endor instruction =&gt;CPI 5   60%</li><li>Hoth instructions =&gt;CPI 8    10%  </li><li>The total numbers of instructions in the program is cut in half</li><li>Is this a good modification, if so, how good is it?(What’s the speedup?)</li></ol><li>Ans. </li><ol><li>Global CPI = weighted avg of CPI= (0.3)(2)+(0.6)(5)+(0.1)(8)=4.4</li><li>Exec time original = I(3)(t)=3It</li><li>Exec time new = 0.5I(4.4)(t)=2.2It</li><li>The speedup ratio = 3/2.2 = 1.36=&gt;36% speedup</li></ol><li>Amdahl’s Law: the amount of overall <span style="color: rgb(255, 38, 0);">speedup that we can get is limited by the fraction of the original execution time</span> affected by the improvement</li><ol><li>A piece of code will have</li><ol><li> some parts that can be split up and executed simultaneously(parallel part) and </li><li>another part that must be executed sequentially(serial part)</li></ol><li>Eg. serial part = 20% of code; parallel part = 80% of code; If I have 2 processor instead of only one, what is the speedup?</li><ol><li>The speedup ratio = (0.2+0.8/2)t/(0.2+0.8)=1.67</li><li>Max speedup ratio = 1/(0.2+0.8/infinite)=5</li></ol><li><span style="color: rgb(255, 38, 0);">Book 1.4.2</span></li><li>Learn from this:</li><ol><li>speedup is limited by fraction w/enhancement</li><li>We want to make the common case fast</li><li>Law of diminishing returns</li></ol></ol><li>Gustafson’s Law: time on a uniprocessor for 1 piece of code= s+p(base time)</li><ol><li>If I have P processors I can do more work in the base time = s+Pp</li><li>speedup = s+P(p)/s+p</li><li>F = fraction of execution time run in parallel = p/s+p</li><li>Speedup= (s/s+p)+Pp/s+P=1-F+F*P</li></ol><li>Digital Signal Processors:</li><ol><li>Arithmetic(Mainly for DSP)</li><ol><li>often DSP’s are real time hearing aid=&gt;20000 samples/sec</li></ol><li>Graphics</li><li>Compares and data movements</li></ol><li>FIR(Finite Impulse Response) digital filtering:</li><ol><li>Input signals=&gt; In array; x[ ]</li><li>Output signals=&gt; Out array; y[ ]</li><li>y[n]= a0*x[n]+a1*x[n-1]…..</li><li>a0, a1 are coefficients</li><li>don’t run out of memory, so store those inputs in a circular buffer</li><li>Parameters need to store:</li><ol><li>address of the newest sample</li><li>length of the buffer</li><li>address of the start of buffer</li><li>initialization</li><li>step size to next element</li></ol><li>Stuff to do:</li><ol><li>Obtain a sample wither ADC(Analog Digital converter); generate an interrupt</li><li>Detect and manage interrupt</li><li>Move the sample into input buffer</li><li>update pointer to the most recent</li><li>zero accumulation</li><li>looping through each coefficient</li><ol><li>fetch coefficient from coefficient’s circular buffer</li><li>update pointer for…..</li><li>fetch input sample from buffer</li><li>update the pointer…</li><li>multiply coefficient a sample</li><li>add product to accumulation</li></ol><li>More output sample to buffer</li><li>move output from buffer to DAC(convert back)</li></ol><li>Stuff in the loop must be done very fast; DSP will try to do as much of this as possible in parallel</li></ol><li>von Neuman architecture:</li><ol><li>Memory&lt;=&gt;CPU: address and data</li><li>Harvard arch:</li><ol><li>Program Memory&lt;=&gt;CPU&lt;=&gt;Data Memory</li></ol></ol></ol></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html>