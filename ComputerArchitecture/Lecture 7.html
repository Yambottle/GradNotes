<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.12 (457936)"/><meta name="altitude" content="170.0371704101562"/><meta name="author" content="chinibottle@gmail.com"/><meta name="created" content="2018-02-13 20:10:40 +0000"/><meta name="latitude" content="32.84263703085109"/><meta name="longitude" content="-96.78206001769659"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-02-13 21:20:39 +0000"/><title>Lecture 7</title></head><body><div><ol start="1"><li>Exceptions/ Traps and interrupt also change execution</li><li>Exception: </li><ol><li>hopefully rare events triggered by the hardware. When an exception occurs, it changes the program flow so that the exception handle can be called to deal with the issue.</li><li>unlike a branch, I don’t know ahead of time when this change could occur</li><li>E.g I/O device interrupts: disk, keyboard: these devices can ask for attention when needed. When they need attention, they assert an interrupt signal. These are generally different priorities of interrupts so things with higher priority get handled first</li><li>I can stop the CPU and begin executing the interrupt handler for the right interrupt</li></ol><li>Traps and operating system calls:</li><ol><li>A trap instruction is used to invoke a service from the OS, like print</li><li>E.g trap 5=&gt; this parameter is used to look up the entry in a trap table and this table entry points to the start of the handler that provided that service</li></ol><li>Instruction tracing and breakpoint: </li><ol><li>In trace mode, CPU traps on every instruction and the trap handler saves the state of the machine after each instruction executes to disk</li><li>Breakpoints are similar, but it only traps for instructions specified by the debugger</li></ol><li>Integer and floating point exceptions:</li><ol><li>overflow and under flow and divide by zero</li></ol><li>Page faults:</li><ol><li> some data may not be in memory yet, but may only be on disk. When we need that data, page fault occurs and we bring the data from the disk to memory</li></ol><li>Misaligned memory access or Data not aligned in memory: </li><ol><li>Memory Protection violation: we try to write to a read only page or try to access another process memory, program must be stopped to present data corruption</li></ol><li>Undefined instruction exception:</li><ol><li>if I only have 8 bits for opcode, but it’s not enough</li><li>some people use the exception handler as an opportunity to encode additional complex instructions that aren’t supported by the machine</li></ol><li>Hardware failure or ALARM:</li><ol><li>if your computer starts detecting a lot of parity error (in memory or on bus) it could pull this exception</li></ol><li>Power failure:</li><ol><li>when a power failure occurs the processor can try to save as much of the machine state as possible before it loses all its power</li></ol><li>If the exception handling has to be synchronized with a particular instruction, then <span style="color: rgb(255, 38, 0);">precise exceptions</span> are required</li><ol><li>if instruction “i” causes an exception</li><li>I need to make the machine complete all instructions through i-1 and save state before exception is handled and then restart at instruction i or i+1</li></ol><li>Options for Operands</li><ol><li>Accumulator: </li><ol><li>one of the operands is implicit in the instruction itself and these is an accumulator register devoted to this</li><li>e.g. calculator</li><li>Accumulator is both savior and destination </li></ol><li>Evaluation stack:</li><ol><li>stack may consist of a set of hardware registers</li><li>operands are implicitly on top of stack</li></ol><li>Registers: </li><ol><li> a set of memory used for fast data storage</li></ol><li>memory operands: </li><ol><li>some ISAs allow you to operate directly on memory</li></ol></ol><li>Characteristics of ISA used in this book( variation of MIPS)</li><ol><li>Load/Store machine</li><ol><li>All ALU operations operate on registers (and possibly immediate values)</li><li>Loads transfer data from memory to registers</li><li>Store do reverse</li></ol><li>All ALU instructions have 3 operands, one of which may be an immediate</li><li>All instructions are 32bits and aligned in memory</li><li>Integer data types: bytes; halfwords; words; double words</li><li>Floating point data types: single precision 4bytes; double</li><li>2 register files </li><ol><li>Integer register file goes from R0 to R31</li><li>R0 is always equal to 0</li><li>Floating point register file F0 to F31</li><li>A double precision value takes up two adjacent registers and has to start on an even number(F0+F1-&gt;F0, F2+F3-&gt;F2)</li><li>book table 3.3</li><ol/></ol></ol></ol></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html>