<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.12 (457936)"/><meta name="altitude" content="164"/><meta name="author" content="chinibottle@gmail.com"/><meta name="created" content="2018-04-12 19:03:29 +0000"/><meta name="latitude" content="32.84286346623183"/><meta name="longitude" content="-96.78269529082777"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-04-17 20:18:42 +0000"/><title>Lecture 22</title></head><body><div><ol start="1"><li>Write policy</li><ol><li>write allocate: when write miss, write into cache</li><li>write non-allocate: when write miss, write into memory</li></ol><li>Coherency of data</li><ol><li>write through: on a write hit, write L1 and lower level</li><li>write back: on a write hit, just write into L1 cache. Set a dirty bit in L1 showing it’s different with lower cache. when I evict this data from cache, I need to update the lower level cache/memory with the correct values; read miss will cause it writes back</li></ol><li>Types of missed:</li><ol><li>Compulsory Miss=&gt; First time the block is accessed, empty</li><li>Conflict Miss=&gt; Two data want the same spot</li><li>Capacity Miss=&gt; Larger than cache, it allows overwrite, but when it needs the first one, miss will show</li><li>Coherence Miss=&gt; occurs in a multiprocessor system</li></ol><li>AMAT: average memory access time = hit rate*hit time+miss rate*miss penalty</li><li>Virtual Memory: virtual address=&gt;physical address(virtual page number to physical page number)</li><ol><li>Use:</li><ol><li>helps to isolate one process from another</li><li>helps avoid having our program space limited to the size of physical memory</li><li>helps programs think they are looking at the same physical address space even though they aren’t, so the beginning location can be standard</li></ol><li>store into a page table=&gt; Page Table Base Address=&gt; cause so big, store in main memory</li><ol><li>Page Table Entry=&gt;row number is the number of virtual page number</li><ol><li>valid bit</li><li>Physical </li><li>dirty bit (writing through to disk is expensive)</li></ol></ol><li>write data</li><ol><li>Memory Management Unit(MMU) get VA(address)</li><li>MMU extracts VPN(virtual page number)</li><li>MMU looks in page table</li><li>get PTE</li><li>if valid, hit</li><li>if invalid, page fault=&gt;this usually handled by software</li></ol><li>we create a special cache for page table TLB( translation lookaside buffer)</li><ol><li>page table entry which included page number</li><li>if we have miss, then go to the main memory to find the page number</li><li>create the PA from Page Number and Page Offset</li><li>search cache for the data</li></ol><li>design TLB:</li><ol><li>Associativity: Direct mapped, set associate, etc.</li><li>Block size</li><li>e.g. </li><ol><li>a 8KB pages</li><li>physical address: 48bits</li><li>PPN: physical page number</li><li>V address: 64bits</li><li>TLB: 16 entries, 2-way set associate, each entry is 1 page</li><li>cache: block size of 128 byte, one word 4 bytes, 4-way set associative, can hold 1024 blocks</li></ol><li>for V address-64bits:</li><ol><li>Page offset: log2(2^3*2^10)-&gt;13 bits(8KB pages)</li><li>for TLB mapping, # of sets is 16 entries/2 ways=8 sets-&gt;3 bits</li><li>for tag, we look page table base address, then the physical page number= PTBA+(size of page table entry)*VPN-&gt;13bits</li></ol><li>for physical address-48bits:</li><ol><ol/><li>look in cache</li><ol><li>which byte in word(4 byte one word)-&gt;2 bits</li><li>word in block-&gt;5 bits-&gt;tell you which word in the cache block</li><li>set in cache-&gt;8 bits</li><li>tag-&gt;33 bits</li></ol></ol><li>Problem: page tables can be very large because they have an entry for entry virtual page number</li><ol><li>32 bits VA=&gt;4KB page size, 4 byte page table entry</li><li>How much memory space is required to store the page table?</li><ol><li># of page table entry * bytes of per page table entry</li><li># of page table entry depends on the tag length </li></ol></ol><li>To solve this, we use page table hierarchy-&gt;table of page tables</li><ol><li>start level page 4MB chucks-&gt; size of VA/ 4MB chucks-&gt; number of first level table entry</li><li>second level page 4KB chucks-&gt; size of chuck/ 2KB chucks-&gt; number of real page table entry</li><li>then VA:</li><ol><li>store every level page table offset and the VPO of the real page table entry</li></ol></ol><li>Inverted Page Table:-&gt;point back to the physical address</li><ol><li> we only need as many PTE as there are physical page in memory</li><li>inverted PTE contain:</li><ol><li>process ID of owning process</li><li>virtual page number</li><li>valid, dirty, protection bits</li></ol><li>e.g.</li><ol><li>PID: 4</li><li>VP: VPN:6, VPO: 25</li><li>inverted page table entry: 4 map with 6-&gt;entry number is 3</li><li>PP: PPN:3, PPO:25</li></ol></ol><li>We don’t want to compare the whole inverted table</li><ol><li>so we use hash to map them all </li></ol></ol></ol></ol><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html>