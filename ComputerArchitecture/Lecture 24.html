<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.12 (457936)"/><meta name="altitude" content="177.2829284667969"/><meta name="author" content="chinibottle@gmail.com"/><meta name="created" content="2018-05-01 19:10:05 +0000"/><meta name="latitude" content="32.86151270919623"/><meta name="longitude" content="-96.76681915379022"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-05-01 20:15:56 +0000"/><title>Lecture 24</title></head><body><ol><li><div>Multiprocessor</div></li><ol><li><div>Shared memory</div></li><ol><li><div>for small scale</div></li><li><div>bus interconnect</div></li></ol><li><div>Message Passing</div></li><ol><li><div>for big scale</div></li><li><div>network on chips</div></li></ol></ol><li><div>Example code for matrix multiplication</div></li><ol><li><div>sum=0;</div></li><li style=""><div>for i to n</div></li><ol><li><div>for j to n</div></li><ol><li><div>c[i,j]=0</div></li><li><div>for k to n</div></li><ol><li><div>c[i,j]=c[i,j]+a[i,k]+b[k,j]</div></li></ol></ol><li><div>sum+=c[i,j]</div></li></ol><li><div>When we parallelize this, each processor will get a subset of the rows to calculate</div></li><ol><li><div>Shared memory</div></li><ol><li><div>each processor has pid</div></li><li><div>the low = pid*N/n proc</div></li><li><div>the high = low+N/n proc ???</div></li><li><div>mysum=0, sum=0</div></li><li><div>for low to high</div></li><ol><li><div>for i to n</div><div/></li><ol><li><div>for j to n</div></li><ol><li><div>c[i,j]=0</div></li><li><div>for k to n</div></li><li><div>c[i,j]=c[i,j]+a[i,k]*b[k,j]</div></li></ol><li><div>mysum+=c[i,j]</div></li></ol></ol><li><div>BERRIER(BAR); synchronized -&gt;wait until all proc get here</div></li><li><div>LOCK(LV);</div></li><ol><li><div>sum+=mysum</div></li></ol><li><div>UNLOCK(LV);</div></li></ol><li><div>Message passing</div></li><ol><li><div>use a master node to distribute the data and collect it</div></li><li><div>for example processor 0 is master node</div></li><li><div>myN = N/proc</div></li><li><div>if(pid==0)</div></li><ol><li><div>for i to n proc</div></li><ol><li><div>k=i*N/n proc</div></li><li><div>SEND(&amp;a[k,0], myN*N*sizeof(float), i, int 1)</div></li><ol><li><div>from address, length of data, which processor, message tag</div></li></ol><li><div>SEND(&amp;b[k,0], myN*N*sizeof(float), i, int 2)</div></li></ol></ol><li><div>else</div></li><ol><li><div>RECV(&amp;a[0,0], myN*N*sizeof(float), 0, int 1)</div></li><li><div>RECV(&amp;b[0,0], myN*N*sizeof(float), 0, int 2)</div></li></ol></ol></ol></ol><li><div>Bus-based shared memory systems</div></li><ol><li><div>broadcast</div></li><li><div>all processor attached to the bus</div></li><li><div>each processor has a private cache</div></li><li><div>each private cache attach to the bus</div></li><li><div>bus also attach to memory</div></li></ol><li><div>Cache coherence</div></li><ol><li><div>if and only if all processor, at any point time M, have a consistent view of the last global written value to that location</div></li><ol><li><div>if wrong data, all will have consistent wrong data</div></li></ol><li><div>Write through cache: update memory on every write</div></li><li><div>Write back cache: only update cache set data bits</div></li></ol><li><div>Eg. Snoopy cache protocol</div></li><ol><li><div>single cache level</div></li><li><div>blocking</div></li><li><div>write through</div></li><li><div>write allocate cache-&gt;allocate while writing</div></li><li><div><img src="Lecture%2024.html.resources/Screen%20Shot%202018-05-01%20at%2014.50.59.png" height="384" width="916"/></div></li><li><div>read hit=&gt;return data to proc from local cache-&gt;proc personal cache</div></li><li><div>read miss=&gt; put request in request buffer, then it will show on bus</div></li><ol><li><div>bus-read, then memory return the data</div></li></ol><li><div>write hit=&gt;put write request in the buffer, then it show on bus</div></li><ol><li><div>bus-write, then write to memory</div></li><li><div>other caches will compare the tag, if change or not</div></li><li><div>value write in local cache</div></li></ol><li><div>write miss=&gt;put write miss request into buffer, then it show on bus</div></li><ol><li><div>bus-read-exclusive(BUSRdX)</div></li><li><div>Copies data from memory into local cache and signals the other processor to invalidate their copies</div></li><li><div>update memory</div></li><li><div>update local cache</div></li></ol><li><div>Valid&amp;Invalid=&gt;video</div></li><li><div>Problem: A lot of bus traffic</div></li><ol><li><div>Write back protocol</div></li><li><div>MSI protocol: 3 states</div></li><ol><li><div>M: modified(dirty)???</div></li><li><div>S: shared(clean)</div></li><li><div>I: invalid???</div></li></ol><li><div>3 states change cycle=&gt;video</div></li></ol></ol></ol><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html>