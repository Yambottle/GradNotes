<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.12 (457936)"/><meta name="altitude" content="169.7676849365234"/><meta name="author" content="chinibottle@gmail.com"/><meta name="created" content="2018-02-27 20:03:41 +0000"/><meta name="latitude" content="32.84305975902748"/><meta name="longitude" content="-96.78261788760838"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-03-01 20:03:11 +0000"/><title>Lecture 11</title></head><body><div><div>Review</div><ol start="1"><li>In out of order model, more forwarding path and more stalls due RAW hazards</li><li>Latency</li><li>Structural hazard: e.g. load a FP instruction at the same time</li></ol><div><br/></div></div><div><ol start="1"><li>Precise exception discussion:</li><ol><li>For the pipeline in 3.8 is hard to enforce precise exception]</li><ol><li>By the time I know of an exceptions, a subsequent instruction in program order could have already completed</li><li>e.g. DIV.S(FP) =&gt;divide by 0 exception; next instruction is ADD(int) the result of DIV.S=&gt; ADD before the exception raised</li></ol><li>modify the pipeline to delay MEM and WB</li><ol><li>IF ID F1 F2 F3 F4 F5 MEM WB</li><li>IF ID EX F2 F3 F4 F5 MEM WB=&gt; combine the F2~WB together</li><li>then it needs F2~WB forwarding lines to EX</li></ol><li>this will be better unless check before the ID</li><ol><li>IF ID EX MEM F3 F4 F5 WB</li><li>this one needs less stalls</li></ol></ol><li>Superpipelined vs Superscalar architecture</li><ol><li>Superpipelined: 5 stage pipeline-&gt; break one stage into the fastest clock cycles( maybe ) stages</li><li>Superscalar: I can fetch multiple instruction from memory at the same time and possibly put them into the pipeline at the same time(int and FP at the same time)</li><li>CPI: clock cycles per instruction</li><ol><li>once go to superscalar, we will think about IPC</li></ol></ol><li>Static pipeline control hazard: </li><ol><li>taken is to go somewhere else</li><li>Default: predict not taken-&gt;lose 2 clock cycles for each taken branch</li><li>opcode : BEZ, BNEZ</li><li>BNEZ is taken( let loop run again), BEZ is not taken</li><li>Compiler based:</li><ol><li>minimize the number of branch instructions</li><li>set a prediction bit that will be read with the instructions and tell the hardware what to predict</li><li>static instruction scheduling </li><ol><li>local: schedule within a basic blocks</li><li>global: schedule across basic blocks</li></ol><li>a basic block is a set of instructions such that if one instruction in the block is executed all of them are</li><li>a basic block can’t contain a branch or jump instruction, unless it is the last instruction in the block (usually the end of a block is a branch or jump)</li><li>a basic block can’t contain an instruction that is a branch/jump target unless it is the first instruction in the block; and there is no overlap</li><li>because most code contain 20-25% branches, basic blocks tend to be small</li><li>scheduling within a basic block doesn’t help too much</li><li>add more instructions inside the loop to reduce the branches</li></ol><li>So, to make bigger basic blocks, we try to remove branches by doing loop unrolling</li><li><font color="#ff2600">video </font></li></ol></ol><ol start="1"><ol><li>BNEZ not taken-&gt; spend 3 cycles; taken-&gt; spend 1 cycle</li><ol><li>predict not taken is cheap, don’t need to figure out where to go</li><li>that’s why 3 or 1,</li><li>when predict , if wrong, you need to kill two instruction before that, so it ’s  3</li></ol></ol></ol><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html>