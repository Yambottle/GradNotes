<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.12 (457936)"/><meta name="altitude" content="171.5677795410156"/><meta name="author" content="chinibottle@gmail.com"/><meta name="created" content="2018-02-01 20:07:35 +0000"/><meta name="latitude" content="32.84294376334096"/><meta name="longitude" content="-96.78272054207537"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-02-01 21:16:16 +0000"/><title>Lecture 4</title></head><body><div><ol start="1"><li>Difference between von Neumann of Harvard Arch</li><ol><li>von:</li><ol><li>Memory&lt;=&gt;CPU(address and data) </li><li>only one bus, transfer data serially</li></ol><li>Harvard:</li><ol><li>separate instructions and data to avoid above</li><li>Program Memory(instructions)&lt;=&gt;CPU&lt;=&gt;Data Memory</li><li>Now we can fetch instructions and data at the same time</li><li>E.g y[n]= a0*x[n]+a1*x[n-1]….. </li><li>Problem: Because ‘a' and ‘x’ are both needed, the data memory bus is twice as busy as the program memory bus</li><ol><li>Option one: add buses; too expensive</li><li>Option two: 2 data buses have to do twice as much address decoding</li><li>Option three: sore data and coefficients next to each other as 2 words in the same buffer</li><li>Difficulty is we have to keep updating ‘x', but not ‘a’, so this makes reading and writing to memory a bit more complex; but still possible</li></ol><li>Chosen Solution: Because so many app involved loops, the instructions run are repeated multiple times. Thus, we can use the program memory to hold instructions for half the data(‘a’); create an instruction cache for the instructions</li></ol><li>Newer Arch:</li><ol><li>PM instructions(secondary data)&lt;=&gt;CPU included instruction cache&lt;=&gt;DM</li><li>Cache: is a small fast memory located close to the processor that contains data/instructions that were used recently and/or are likely to be used soon. </li><li>Spatial locality: Data placed in cache in blocks of multiple words</li><li>Temporal locality: Put data in cache on a cache miss or replace LRU data</li></ol></ol><li>Analog Devices SHARCs(Super Harvard Arch): Instruction cache holds 32 instructions</li><ol><li>First time through the loop, everything is slow because I have to populate the cache with instructions</li><li>After first time, transfer of one ‘a’ and ‘x’ is simultaneously done in one cycle</li><li>Another issue is that ‘x’ values are real time a need to be update in DM on a regular basis<span style="color: rgb(255, 38, 0);">???</span></li><li>DMA(Direct Memory Access): In the SHARC dedicated hardware lets data be transferred to memory directly without going through the CPU’s data registers</li></ol><li>Other Optimizations: </li><ol><li>Data is stored in circular buffer</li><ol><li>Address lines of the program and data memory are controlled by DAG(Data Address Generators) that are designed to handle circular buffers</li><li>Each DAG in SHARC can control up to 8 buffers=&gt; 8(buffers)*4(number of values to define buffer) = 32 values</li></ol><li>They can also be configured to handle <span style="color: rgb(255, 38, 0);">bit-reversed???</span> addressing</li><li>In addition to this DSP has a regular register file</li><ol><li>intermediate calculations</li><li>flags for program control </li><li>buffer to transfer data to coprocessor</li></ol></ol><li>Operations DSP should do very efficiently:</li><ol><li> Multiply accumulate</li><li>Lots of Shifts</li></ol><li>To finish this efficiently:</li><ol><li>Multiplier</li><li>ALU=&gt;Arithmetic Logic Unit: </li><ol><li>conversions between </li><ol><li>fixed point: particular type of number</li><li>floating point: precision</li></ol></ol><li>Barrel Shifter:</li><ol><li>Shifting: arithmetic(keep sign as the same) and logical(shift in zero)</li><ol><li>shift register=&gt; E.g all the DQ flip-flops connected together; Not good for a DSP because we shift only one space per clock</li><ol><li>we want thins to be faster</li><li>time required is also unpredictable because it depends on magnitude of the shift</li></ol></ol><li>=&gt;Alternative Barrel Shift Design</li><ol><li>Goal: Shift an arbitrary amount in on clock</li><li>E.g 1</li><ol><li>Input X is: X3 X2 X1 X0</li><li>Output Y is: circular shift right 0 to 4 bits</li><li>Input S shift amount</li><li>For example if s=2, y=X1 X0 X3 X2</li><li>MUX: <img src="Lecture%204.html.resources/Screen%20Shot%202018-02-01%20at%2015.08.38.png" height="384" width="412"/><br/></li><li>MUX is hero to shift</li></ol></ol><li>Rotating<span style="color: rgb(255, 38, 0);">??? </span></li><li>Extract and deposit segments<span style="color: rgb(255, 38, 0);">???</span></li></ol></ol></ol></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html>